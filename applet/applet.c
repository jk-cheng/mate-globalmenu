/* applet.c generated by valac, the Vala compiler
 * generated from applet.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <panel-applet.h>
#include <globalmenu-settings.h>
#include <globalmenu-server.h>
#include <glib/gi18n-lib.h>
#include <stdlib.h>
#include <string.h>
#include <libbonoboui.h>
#include <libwnck/libwnck.h>
#include <gdk/gdk.h>
#include <gtk/gtk.h>
#include <gconf/gconf-client.h>
#include <configmake.h>
#include <glib/gstdio.h>


#define TYPE_APPLET (applet_get_type ())
#define APPLET(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_APPLET, GlobalMenuPanelApplet))
#define APPLET_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_APPLET, GlobalMenuPanelAppletClass))
#define IS_APPLET(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_APPLET))
#define IS_APPLET_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_APPLET))
#define APPLET_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_APPLET, GlobalMenuPanelAppletClass))

typedef struct _GlobalMenuPanelApplet GlobalMenuPanelApplet;
typedef struct _GlobalMenuPanelAppletClass GlobalMenuPanelAppletClass;
typedef struct _GlobalMenuPanelAppletPrivate GlobalMenuPanelAppletPrivate;

#define TYPE_SWITCHER (switcher_get_type ())
#define SWITCHER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SWITCHER, Switcher))
#define SWITCHER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SWITCHER, SwitcherClass))
#define IS_SWITCHER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SWITCHER))
#define IS_SWITCHER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SWITCHER))
#define SWITCHER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SWITCHER, SwitcherClass))

typedef struct _Switcher Switcher;
typedef struct _SwitcherClass SwitcherClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _gnomenu_background_unref0(var) ((var == NULL) ? NULL : (var = (gnomenu_background_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))

#define TYPE_GCONF_DIALOG (gconf_dialog_get_type ())
#define GCONF_DIALOG(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_GCONF_DIALOG, GConfDialog))
#define GCONF_DIALOG_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_GCONF_DIALOG, GConfDialogClass))
#define IS_GCONF_DIALOG(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_GCONF_DIALOG))
#define IS_GCONF_DIALOG_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_GCONF_DIALOG))
#define GCONF_DIALOG_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_GCONF_DIALOG, GConfDialogClass))

typedef struct _GConfDialog GConfDialog;
typedef struct _GConfDialogClass GConfDialogClass;

struct _GlobalMenuPanelApplet {
	PanelApplet parent_instance;
	GlobalMenuPanelAppletPrivate * priv;
};

struct _GlobalMenuPanelAppletClass {
	PanelAppletClass parent_class;
};

struct _GlobalMenuPanelAppletPrivate {
	MatenuGlobalSettings* settings;
	MatenuMenuBarBox* menubars;
	MatenuGlobalMenuBar* main_menubar;
	MatenuMenuBar* tiny_menubar;
	Switcher* switcher;
	gboolean initialized;
	gboolean disposed;
	gboolean _disable_module_check;
	gboolean _tiny_mode;
	gboolean _has_handle;
};


static char** applet_subs;
static gint applet_subs_length1;
static char** applet_subs = NULL;
static gint applet_subs_length1 = 0;
static gint _applet_subs_size_ = 0;
static gpointer applet_parent_class = NULL;

GType applet_get_type (void) G_GNUC_CONST;
GType switcher_get_type (void) G_GNUC_CONST;
#define APPLET_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_APPLET, GlobalMenuPanelAppletPrivate))
enum  {
	APPLET_DUMMY_PROPERTY,
	APPLET_DISABLE_MODULE_CHECK,
	APPLET_TINY_MODE,
	APPLET_HAS_HANDLE
};
Switcher* switcher_new (void);
Switcher* switcher_construct (GType object_type);
#define APPLET_IID "OAFIID:GlobalMenu_PanelApplet"
#define APPLET_applet_menu_xml_template "\n" \
"<popup name=\"button3\">\n" \
"\t<menuitem name=\"Preferences\" \n" \
"\t\tverb=\"Preferences\" \n" \
"\t\t_label=\"@Preferences@\"\n" \
"\t\tpixtype=\"stock\" \n" \
"\t\tpixname=\"gtk-preferences\"/>\n" \
"\t<menuitem name=\"Help\" \n" \
"\t\tverb=\"Help\" \n" \
"\t\t_label=\"@Help@\"\n" \
"\t\tpixtype=\"stock\" \n" \
"\t\tpixname=\"gtk-help\"/>\n" \
"\t<menuitem name=\"About\" \n" \
"\t\tverb=\"About\" \n" \
"\t\t_label=\"@About@\"\n" \
"\t\tpixtype=\"stock\" \n" \
"\t\tpixname=\"gtk-about\"/>\n" \
"</popup>\n" \
"\t"
#define APPLET_APPLET_NAME _ ("mate-applet-globalmenu")
#define APPLET_APPLET_ICON "globalmenu"
#define APPLET_GCONF_SCHEMA_DIR "/schemas/apps/mate-applet-globalmenu/prefs"
static void applet_applet_menu_clicked (BonoboUIComponent* component, GlobalMenuPanelApplet* self, const char* cname);
GlobalMenuPanelApplet* applet_new (void);
GlobalMenuPanelApplet* applet_construct (GType object_type);
static void applet_real_dispose (GObject* base);
void switcher_set_current_window (Switcher* self, WnckWindow* value);
static void applet_on_active_window_changed (GlobalMenuPanelApplet* self);
static void applet_on_change_background (GlobalMenuPanelApplet* self, PanelAppletBackgroundType type, GdkColor* color, GdkPixmap* pixmap);
static void applet_update_size (GlobalMenuPanelApplet* self);
static void applet_get_prefs (GlobalMenuPanelApplet* self);
static void _lambda4_ (const char* key, void* value, GlobalMenuPanelApplet* self);
static void __lambda4__gconf_client_value_changed (GConfClient* _sender, const char* key, void* value, gpointer self);
char* template_replace (const char* template, char** subs, int subs_length1);
void applet_init (GlobalMenuPanelApplet* self);
void switcher_set_max_size (Switcher* self, gint value);
void switcher_set_show_icon (Switcher* self, gboolean value);
void switcher_set_show_label (Switcher* self, gboolean value);
void switcher_set_show_window_actions (Switcher* self, gboolean value);
void switcher_set_show_window_list (Switcher* self, gboolean value);
void switcher_set_enable_search_box (Switcher* self, gboolean value);
void applet_set_has_handle (GlobalMenuPanelApplet* self, gboolean value);
void applet_set_tiny_mode (GlobalMenuPanelApplet* self, gboolean value);
GConfDialog* gconf_dialog_new (const char* dialog_title);
GConfDialog* gconf_dialog_construct (GType object_type, const char* dialog_title);
GType gconf_dialog_get_type (void) G_GNUC_CONST;
void gconf_dialog_add_key_group (GConfDialog* self, const char* group_name, char** keys, int keys_length1);
static GtkDialog* applet_get_pref_dialog (GlobalMenuPanelApplet* self);
static void applet_show_about (GlobalMenuPanelApplet* self);
static void applet_show_preferences (GlobalMenuPanelApplet* self);
static void applet_show_help (GlobalMenuPanelApplet* self);
static gboolean applet_real_button_press_event (GtkWidget* base, GdkEventButton* event);
gboolean applet_get_has_handle (GlobalMenuPanelApplet* self);
static void applet_real_size_request (GtkWidget* base, GtkRequisition* req);
static gboolean _lambda5_ (GtkWidget* widget, GdkEventButton* event, GlobalMenuPanelApplet* self);
static gboolean __lambda5__gtk_widget_button_press_event (GtkWidget* _sender, GdkEventButton* event, gpointer self);
static void applet_setup_popup_menu (GlobalMenuPanelApplet* self, GtkWidget* widget);
gboolean applet_get_disable_module_check (GlobalMenuPanelApplet* self);
void applet_set_disable_module_check (GlobalMenuPanelApplet* self, gboolean value);
gboolean applet_get_tiny_mode (GlobalMenuPanelApplet* self);
static void _applet_on_active_window_changed_matenu_global_menu_bar_active_window_changed (GnomenuGlobalMenuBar* _sender, GnomenuWindow* prev_window, gpointer self);
static void _applet_on_change_background_panel_applet_change_background (GlobalMenuPanelApplet* _sender, PanelAppletBackgroundType type, GdkColor* color, GdkPixmap* pixmap, gpointer self);
static void _applet_update_size_panel_applet_change_orient (GlobalMenuPanelApplet* _sender, PanelAppletOrient orient, gpointer self);
static void _applet_update_size_panel_applet_change_size (GlobalMenuPanelApplet* _sender, guint size_hint, gpointer self);
static void _lambda6_ (GlobalMenuPanelApplet* self);
static void __lambda6__gtk_widget_screen_changed (GlobalMenuPanelApplet* _sender, GdkScreen* previous_screen, gpointer self);
static GObject * applet_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
static void applet_finalize (GObject* obj);
static void applet_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void applet_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);

static const BonoboUIVerb APPLET_verbs[4] = {{"About", (BonoboUIVerbFn) applet_applet_menu_clicked, NULL}, {"Help", (BonoboUIVerbFn) applet_applet_menu_clicked, NULL}, {"Preferences", (BonoboUIVerbFn) applet_applet_menu_clicked, NULL}, {NULL, NULL, NULL}};


GlobalMenuPanelApplet* applet_construct (GType object_type) {
	GlobalMenuPanelApplet * self;
	self = g_object_newv (object_type, 0, NULL);
	return self;
}


GlobalMenuPanelApplet* applet_new (void) {
	return applet_construct (TYPE_APPLET);
}


static void applet_real_dispose (GObject* base) {
	GlobalMenuPanelApplet * self;
	self = (GlobalMenuPanelApplet*) base;
	if (!self->priv->disposed) {
		self->priv->disposed = TRUE;
		gnomenu_settings_set_show_local_menu ((GnomenuSettings*) self->priv->settings, TRUE);
		gnomenu_settings_push ((GnomenuSettings*) self->priv->settings);
		panel_applet_set_background_widget ((PanelApplet*) self, NULL);
	}
	G_OBJECT_CLASS (applet_parent_class)->dispose ((GObject*) PANEL_APPLET (self));
}


static void applet_on_active_window_changed (GlobalMenuPanelApplet* self) {
	g_return_if_fail (self != NULL);
	if (gnomenu_global_menu_bar_get_active_window (self->priv->main_menubar) != NULL) {
		switcher_set_current_window (self->priv->switcher, wnck_window_get ((gulong) gnomenu_window_get_xid (gnomenu_global_menu_bar_get_active_window (self->priv->main_menubar))));
	} else {
		switcher_set_current_window (self->priv->switcher, NULL);
	}
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void applet_on_change_background (GlobalMenuPanelApplet* self, PanelAppletBackgroundType type, GdkColor* color, GdkPixmap* pixmap) {
	GnomenuBackground* bg;
	g_return_if_fail (self != NULL);
	bg = gnomenu_background_new ();
	switch (type) {
		case PANEL_NO_BACKGROUND:
		{
			break;
		}
		case PANEL_COLOR_BACKGROUND:
		{
			bg->type = GNOMENU_BACKGROUND_TYPE_COLOR;
			bg->color = *color;
			break;
		}
		case PANEL_PIXMAP_BACKGROUND:
		{
			GdkPixmap* _tmp0_;
			bg->type = GNOMENU_BACKGROUND_TYPE_PIXMAP;
			bg->pixmap = (_tmp0_ = _g_object_ref0 (pixmap), _g_object_unref0 (bg->pixmap), _tmp0_);
			break;
		}
	}
	gnomenu_menu_bar_box_set_background (self->priv->menubars, bg);
	_gnomenu_background_unref0 (bg);
}


static void applet_update_size (GlobalMenuPanelApplet* self) {
	g_return_if_fail (self != NULL);
	switch (panel_applet_get_orient ((PanelApplet*) self)) {
		case PANEL_APPLET_ORIENT_UP:
		{
			gnomenu_menu_bar_box_set_gravity (self->priv->menubars, GNOMENU_GRAVITY_DOWN);
			gnomenu_menu_bar_box_set_pack_direction (self->priv->menubars, GTK_PACK_DIRECTION_LTR);
			gnomenu_menu_bar_box_set_child_pack_direction (self->priv->menubars, GTK_PACK_DIRECTION_LTR);
			gtk_widget_set_size_request ((GtkWidget*) self->priv->menubars, (gint) panel_applet_get_size ((PanelApplet*) self), -1);
			break;
		}
		case PANEL_APPLET_ORIENT_DOWN:
		{
			gnomenu_menu_bar_box_set_gravity (self->priv->menubars, GNOMENU_GRAVITY_DOWN);
			gnomenu_menu_bar_box_set_pack_direction (self->priv->menubars, GTK_PACK_DIRECTION_LTR);
			gnomenu_menu_bar_box_set_child_pack_direction (self->priv->menubars, GTK_PACK_DIRECTION_LTR);
			gtk_widget_set_size_request ((GtkWidget*) self->priv->menubars, (gint) panel_applet_get_size ((PanelApplet*) self), -1);
			break;
		}
		case PANEL_APPLET_ORIENT_LEFT:
		{
			gnomenu_menu_bar_box_set_gravity (self->priv->menubars, GNOMENU_GRAVITY_LEFT);
			gnomenu_menu_bar_box_set_pack_direction (self->priv->menubars, GTK_PACK_DIRECTION_TTB);
			gnomenu_menu_bar_box_set_child_pack_direction (self->priv->menubars, GTK_PACK_DIRECTION_TTB);
			gtk_widget_set_size_request ((GtkWidget*) self->priv->menubars, -1, (gint) panel_applet_get_size ((PanelApplet*) self));
			break;
		}
		case PANEL_APPLET_ORIENT_RIGHT:
		{
			gnomenu_menu_bar_box_set_gravity (self->priv->menubars, GNOMENU_GRAVITY_RIGHT);
			gnomenu_menu_bar_box_set_pack_direction (self->priv->menubars, GTK_PACK_DIRECTION_TTB);
			gnomenu_menu_bar_box_set_child_pack_direction (self->priv->menubars, GTK_PACK_DIRECTION_TTB);
			gtk_widget_set_size_request ((GtkWidget*) self->priv->menubars, -1, (gint) panel_applet_get_size ((PanelApplet*) self));
			break;
		}
	}
}


static void _lambda4_ (const char* key, void* value, GlobalMenuPanelApplet* self) {
	g_return_if_fail (key != NULL);
	applet_get_prefs (self);
}


static void __lambda4__gconf_client_value_changed (GConfClient* _sender, const char* key, void* value, gpointer self) {
	_lambda4_ (key, value, self);
}


void applet_init (GlobalMenuPanelApplet* self) {
	GError * _inner_error_;
	GConfClient* client;
	char* applet_menu_xml;
	g_return_if_fail (self != NULL);
	_inner_error_ = NULL;
	{
		panel_applet_add_preferences ((PanelApplet*) self, APPLET_GCONF_SCHEMA_DIR, &_inner_error_);
		if (_inner_error_ != NULL) {
			goto __catch2_g_error;
		}
	}
	goto __finally2;
	__catch2_g_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		{
			g_warning ("applet.vala:220: %s", e->message);
			_g_error_free0 (e);
		}
	}
	__finally2:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	client = _g_object_ref0 (gconf_client_get_default ());
	if (client != NULL) {
		g_signal_connect_object (client, "value-changed", (GCallback) __lambda4__gconf_client_value_changed, self, 0);
	}
	applet_menu_xml = template_replace (APPLET_applet_menu_xml_template, applet_subs, applet_subs_length1);
	panel_applet_setup_menu ((PanelApplet*) self, applet_menu_xml, APPLET_verbs, self);
	applet_get_prefs (self);
	self->priv->initialized = TRUE;
	_g_free0 (applet_menu_xml);
	_g_object_unref0 (client);
}


static void applet_get_prefs (GlobalMenuPanelApplet* self) {
	GError * _inner_error_;
	g_return_if_fail (self != NULL);
	_inner_error_ = NULL;
	{
		gint _tmp0_;
		_tmp0_ = panel_applet_gconf_get_int ((PanelApplet*) self, "title_max_width", &_inner_error_);
		if (_inner_error_ != NULL) {
			goto __catch3_g_error;
		}
		switcher_set_max_size (self->priv->switcher, _tmp0_);
	}
	goto __finally3;
	__catch3_g_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		{
			_g_error_free0 (e);
		}
	}
	__finally3:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	{
		gboolean _tmp1_;
		_tmp1_ = panel_applet_gconf_get_bool ((PanelApplet*) self, "show_icon", &_inner_error_);
		if (_inner_error_ != NULL) {
			goto __catch4_g_error;
		}
		switcher_set_show_icon (self->priv->switcher, _tmp1_);
	}
	goto __finally4;
	__catch4_g_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		{
			_g_error_free0 (e);
		}
	}
	__finally4:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	{
		gboolean _tmp2_;
		_tmp2_ = panel_applet_gconf_get_bool ((PanelApplet*) self, "show_name", &_inner_error_);
		if (_inner_error_ != NULL) {
			goto __catch5_g_error;
		}
		switcher_set_show_label (self->priv->switcher, _tmp2_);
	}
	goto __finally5;
	__catch5_g_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		{
			_g_error_free0 (e);
		}
	}
	__finally5:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	{
		gboolean _tmp3_;
		_tmp3_ = panel_applet_gconf_get_bool ((PanelApplet*) self, "show_window_actions", &_inner_error_);
		if (_inner_error_ != NULL) {
			goto __catch6_g_error;
		}
		switcher_set_show_window_actions (self->priv->switcher, _tmp3_);
	}
	goto __finally6;
	__catch6_g_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		{
			_g_error_free0 (e);
		}
	}
	__finally6:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	{
		gboolean _tmp4_;
		_tmp4_ = panel_applet_gconf_get_bool ((PanelApplet*) self, "show_window_list", &_inner_error_);
		if (_inner_error_ != NULL) {
			goto __catch7_g_error;
		}
		switcher_set_show_window_list (self->priv->switcher, _tmp4_);
	}
	goto __finally7;
	__catch7_g_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		{
			_g_error_free0 (e);
		}
	}
	__finally7:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	{
		gboolean _tmp5_;
		_tmp5_ = panel_applet_gconf_get_bool ((PanelApplet*) self, "enable_search_box", &_inner_error_);
		if (_inner_error_ != NULL) {
			goto __catch8_g_error;
		}
		switcher_set_enable_search_box (self->priv->switcher, _tmp5_);
	}
	goto __finally8;
	__catch8_g_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		{
			_g_error_free0 (e);
		}
	}
	__finally8:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	{
		gboolean _tmp6_;
		_tmp6_ = panel_applet_gconf_get_bool ((PanelApplet*) self, "use_rgba_colormap", &_inner_error_);
		if (_inner_error_ != NULL) {
			goto __catch9_g_error;
		}
		gnomenu_menu_default_use_rgba_colormap = _tmp6_;
	}
	goto __finally9;
	__catch9_g_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		{
			_g_error_free0 (e);
		}
	}
	__finally9:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	{
		gboolean _tmp7_;
		_tmp7_ = panel_applet_gconf_get_bool ((PanelApplet*) self, "grab_mnemonic_keys", &_inner_error_);
		if (_inner_error_ != NULL) {
			goto __catch10_g_error;
		}
		gnomenu_global_menu_bar_set_grab_keys (self->priv->main_menubar, _tmp7_);
	}
	goto __finally10;
	__catch10_g_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		{
			_g_error_free0 (e);
		}
	}
	__finally10:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	{
		gboolean _tmp8_;
		_tmp8_ = panel_applet_gconf_get_bool ((PanelApplet*) self, "grab_menu_bar_key", &_inner_error_);
		if (_inner_error_ != NULL) {
			goto __catch11_g_error;
		}
		gnomenu_global_menu_bar_set_grab_menu_key (self->priv->main_menubar, _tmp8_);
	}
	goto __finally11;
	__catch11_g_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		{
			_g_error_free0 (e);
		}
	}
	__finally11:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	{
		gboolean _tmp9_;
		_tmp9_ = panel_applet_gconf_get_bool ((PanelApplet*) self, "per_monitor_mode", &_inner_error_);
		if (_inner_error_ != NULL) {
			goto __catch12_g_error;
		}
		gnomenu_global_menu_bar_set_per_monitor_mode (self->priv->main_menubar, _tmp9_);
	}
	goto __finally12;
	__catch12_g_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		{
			_g_error_free0 (e);
		}
	}
	__finally12:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	{
		gboolean _tmp10_;
		_tmp10_ = panel_applet_gconf_get_bool ((PanelApplet*) self, "has_handle", &_inner_error_);
		if (_inner_error_ != NULL) {
			goto __catch13_g_error;
		}
		applet_set_has_handle (self, _tmp10_);
	}
	goto __finally13;
	__catch13_g_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		{
			_g_error_free0 (e);
		}
	}
	__finally13:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	{
		gboolean _tmp11_;
		_tmp11_ = panel_applet_gconf_get_bool ((PanelApplet*) self, "tiny_mode", &_inner_error_);
		if (_inner_error_ != NULL) {
			goto __catch14_g_error;
		}
		applet_set_tiny_mode (self, _tmp11_);
	}
	goto __finally14;
	__catch14_g_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		{
			_g_error_free0 (e);
		}
	}
	__finally14:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	{
		gboolean _tmp12_;
		_tmp12_ = panel_applet_gconf_get_bool ((PanelApplet*) self, "show_local_menu", &_inner_error_);
		if (_inner_error_ != NULL) {
			goto __catch15_g_error;
		}
		gnomenu_settings_set_show_local_menu ((GnomenuSettings*) self->priv->settings, _tmp12_);
	}
	goto __finally15;
	__catch15_g_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		{
			_g_error_free0 (e);
		}
	}
	__finally15:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	{
		gboolean _tmp13_;
		_tmp13_ = panel_applet_gconf_get_bool ((PanelApplet*) self, "show_menu_icons", &_inner_error_);
		if (_inner_error_ != NULL) {
			goto __catch16_g_error;
		}
		gnomenu_settings_set_show_menu_icons ((GnomenuSettings*) self->priv->settings, _tmp13_);
	}
	goto __finally16;
	__catch16_g_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		{
			_g_error_free0 (e);
		}
	}
	__finally16:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	gnomenu_settings_push ((GnomenuSettings*) self->priv->settings);
}


static GtkDialog* applet_get_pref_dialog (GlobalMenuPanelApplet* self) {
	GtkDialog* result = NULL;
	GConfDialog* gcd;
	char* root;
	gint _tmp1__length1;
	char** _tmp1_;
	char** _tmp0_ = NULL;
	gint _tmp3__length1;
	char** _tmp3_;
	char** _tmp2_ = NULL;
	gint _tmp5__length1;
	char** _tmp5_;
	char** _tmp4_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	gcd = g_object_ref_sink (gconf_dialog_new (_ ("Global Menu Applet Preferences")));
	root = panel_applet_get_preferences_key ((PanelApplet*) self);
	gconf_dialog_add_key_group (gcd, _ ("General Settings"), (_tmp1_ = (_tmp0_ = g_new0 (char*, 3 + 1), _tmp0_[0] = g_strconcat (root, "/show_local_menu", NULL), _tmp0_[1] = g_strconcat (root, "/show_menu_icons", NULL), _tmp0_[2] = g_strconcat (root, "/per_monitor_mode", NULL), _tmp0_), _tmp1__length1 = 3, _tmp1_), 3);
	_tmp1_ = (_vala_array_free (_tmp1_, _tmp1__length1, (GDestroyNotify) g_free), NULL);
	gconf_dialog_add_key_group (gcd, _ ("Applet"), (_tmp3_ = (_tmp2_ = g_new0 (char*, 5 + 1), _tmp2_[0] = g_strconcat (root, "/has_handle", NULL), _tmp2_[1] = g_strconcat (root, "/tiny_mode", NULL), _tmp2_[2] = g_strconcat (root, "/use_rgba_colormap", NULL), _tmp2_[3] = g_strconcat (root, "/grab_mnemonic_keys", NULL), _tmp2_[4] = g_strconcat (root, "/grab_menu_bar_key", NULL), _tmp2_), _tmp3__length1 = 5, _tmp3_), 5);
	_tmp3_ = (_vala_array_free (_tmp3_, _tmp3__length1, (GDestroyNotify) g_free), NULL);
	gconf_dialog_add_key_group (gcd, _ ("Switcher"), (_tmp5_ = (_tmp4_ = g_new0 (char*, 6 + 1), _tmp4_[0] = g_strconcat (root, "/show_icon", NULL), _tmp4_[1] = g_strconcat (root, "/show_name", NULL), _tmp4_[2] = g_strconcat (root, "/title_max_width", NULL), _tmp4_[3] = g_strconcat (root, "/show_window_actions", NULL), _tmp4_[4] = g_strconcat (root, "/show_window_list", NULL), _tmp4_[5] = g_strconcat (root, "/enable_search_box", NULL), _tmp4_), _tmp5__length1 = 6, _tmp5_), 6);
	_tmp5_ = (_vala_array_free (_tmp5_, _tmp5__length1, (GDestroyNotify) g_free), NULL);
	result = (GtkDialog*) gcd;
	_g_free0 (root);
	return result;
}


static void applet_applet_menu_clicked (BonoboUIComponent* component, GlobalMenuPanelApplet* self, const char* cname) {
	GQuark _tmp1_;
	const char* _tmp0_;
	static GQuark _tmp1__label0 = 0;
	static GQuark _tmp1__label1 = 0;
	static GQuark _tmp1__label2 = 0;
	g_return_if_fail (self != NULL);
	g_return_if_fail (component != NULL);
	g_return_if_fail (cname != NULL);
	_tmp0_ = cname;
	_tmp1_ = (NULL == _tmp0_) ? 0 : g_quark_from_string (_tmp0_);
	if (_tmp1_ == ((0 != _tmp1__label0) ? _tmp1__label0 : (_tmp1__label0 = g_quark_from_static_string ("About"))))
	switch (0) {
		default:
		{
			applet_show_about (self);
			break;
		}
	} else if (_tmp1_ == ((0 != _tmp1__label1) ? _tmp1__label1 : (_tmp1__label1 = g_quark_from_static_string ("Preferences"))))
	switch (0) {
		default:
		{
			applet_show_preferences (self);
			break;
		}
	} else if (_tmp1_ == ((0 != _tmp1__label2) ? _tmp1__label2 : (_tmp1__label2 = g_quark_from_static_string ("Help"))))
	switch (0) {
		default:
		{
			applet_show_help (self);
			break;
		}
	}
}


static void applet_show_about (GlobalMenuPanelApplet* self) {
	GError * _inner_error_;
	GtkAboutDialog* dialog;
	char* ver;
	g_return_if_fail (self != NULL);
	_inner_error_ = NULL;
	dialog = g_object_ref_sink ((GtkAboutDialog*) gtk_about_dialog_new ());
	gtk_about_dialog_set_program_name (dialog, APPLET_APPLET_NAME);
	ver = g_strdup (VERSION);
	gtk_about_dialog_set_version (dialog, ver);
	gtk_about_dialog_set_website (dialog, "http://code.google.com/p/gnome2-globalmenu");
	gtk_about_dialog_set_website_label (dialog, _ ("Project Home"));
	gtk_about_dialog_set_wrap_license (dialog, FALSE);
	{
		char* license;
		char* _tmp1_;
		char* _tmp0_ = NULL;
		license = NULL;
		g_file_get_contents (DOCDIR "/COPYING", &_tmp0_, NULL, &_inner_error_);
		license = (_tmp1_ = _tmp0_, _g_free0 (license), _tmp1_);
		if (_inner_error_ != NULL) {
			_g_free0 (license);
			if (_inner_error_->domain == G_FILE_ERROR) {
				goto __catch17_g_file_error;
			}
			_g_free0 (license);
			_g_free0 (ver);
			_g_object_unref0 (dialog);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
		gtk_about_dialog_set_license (dialog, license);
		_g_free0 (license);
	}
	goto __finally17;
	__catch17_g_file_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		{
			g_warning ("applet.vala:352: %s", e->message);
			_g_error_free0 (e);
		}
	}
	__finally17:
	if (_inner_error_ != NULL) {
		_g_free0 (ver);
		_g_object_unref0 (dialog);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	{
		char* authors;
		char* _tmp3_;
		char* _tmp2_ = NULL;
		char** _tmp5_;
		gint _authors_array_size_;
		gint authors_array_length1;
		char** _tmp4_;
		char** authors_array;
		authors = NULL;
		g_file_get_contents (DOCDIR "/AUTHORS", &_tmp2_, NULL, &_inner_error_);
		authors = (_tmp3_ = _tmp2_, _g_free0 (authors), _tmp3_);
		if (_inner_error_ != NULL) {
			_g_free0 (authors);
			if (_inner_error_->domain == G_FILE_ERROR) {
				goto __catch18_g_file_error;
			}
			_g_free0 (authors);
			_g_free0 (ver);
			_g_object_unref0 (dialog);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
		authors_array = (_tmp5_ = _tmp4_ = g_strsplit (authors, "\n", 0), authors_array_length1 = _vala_array_length (_tmp4_), _authors_array_size_ = authors_array_length1, _tmp5_);
		gtk_about_dialog_set_authors (dialog, authors_array);
		authors_array = (_vala_array_free (authors_array, authors_array_length1, (GDestroyNotify) g_free), NULL);
		_g_free0 (authors);
	}
	goto __finally18;
	__catch18_g_file_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		{
			g_warning ("applet.vala:360: %s", e->message);
			_g_error_free0 (e);
		}
	}
	__finally18:
	if (_inner_error_ != NULL) {
		_g_free0 (ver);
		_g_object_unref0 (dialog);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	gtk_about_dialog_set_logo_icon_name (dialog, APPLET_APPLET_ICON);
	gtk_about_dialog_set_translator_credits (dialog, _ ("translator-credits"));
	gtk_window_set_icon_name ((GtkWindow*) dialog, "gtk-about");
	gtk_dialog_run ((GtkDialog*) dialog);
	gtk_object_destroy ((GtkObject*) dialog);
	_g_free0 (ver);
	_g_object_unref0 (dialog);
}


static void applet_show_preferences (GlobalMenuPanelApplet* self) {
	GtkDialog* gcd;
	g_return_if_fail (self != NULL);
	gcd = applet_get_pref_dialog (self);
	switch (gtk_dialog_run (gcd)) {
		case GTK_RESPONSE_HELP:
		{
			applet_show_help (self);
			break;
		}
	}
	gtk_object_destroy ((GtkObject*) gcd);
	_g_object_unref0 (gcd);
}


static void applet_show_help (GlobalMenuPanelApplet* self) {
	GError * _inner_error_;
	g_return_if_fail (self != NULL);
	_inner_error_ = NULL;
	{
		gtk_show_uri (NULL, "http://code.google.com/p/gnome2-globalmenu/wiki/HelpCentral", (guint32) GDK_CURRENT_TIME, &_inner_error_);
		if (_inner_error_ != NULL) {
			goto __catch19_g_error;
		}
	}
	goto __finally19;
	__catch19_g_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		{
			g_warning ("applet.vala:384: %s", e->message);
			_g_error_free0 (e);
		}
	}
	__finally19:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
}


static gboolean applet_real_button_press_event (GtkWidget* base, GdkEventButton* event) {
	GlobalMenuPanelApplet * self;
	gboolean result = FALSE;
	self = (GlobalMenuPanelApplet*) base;
	if ((*event).button == 3) {
		result = bonobo_control_do_popup (panel_applet_get_control ((PanelApplet*) self), (*event).button, (*event).time);
		return result;
	}
	result = FALSE;
	return result;
}


static void applet_real_size_request (GtkWidget* base, GtkRequisition* req) {
	GlobalMenuPanelApplet * self;
	gint* _tmp1_;
	gint _hints_size_;
	gint hints_length1;
	gint _tmp0_;
	gint* hints;
	self = (GlobalMenuPanelApplet*) base;
	GTK_WIDGET_CLASS (applet_parent_class)->size_request ((GtkWidget*) PANEL_APPLET (self), req);
	hints = (_tmp1_ = gnomenu_menu_bar_box_get_size_hints (self->priv->menubars, &_tmp0_), hints_length1 = _tmp0_, _hints_size_ = hints_length1, _tmp1_);
	g_assert ((hints_length1 % 2) == 0);
	if (applet_get_has_handle (self)) {
		panel_applet_set_size_hints ((PanelApplet*) self, hints, hints_length1, 0);
	}
}


static gboolean _lambda5_ (GtkWidget* widget, GdkEventButton* event, GlobalMenuPanelApplet* self) {
	gboolean result = FALSE;
	g_return_val_if_fail (widget != NULL, FALSE);
	if ((*event).button == 3) {
		gboolean _tmp1_;
		GlobalMenuPanelApplet* _tmp0_;
		g_signal_emit_by_name ((_tmp0_ = self, GTK_IS_WIDGET (_tmp0_) ? ((GtkWidget*) _tmp0_) : NULL), "button-press-event", event, &_tmp1_);
		_tmp1_;
		result = TRUE;
		return result;
	} else {
		result = FALSE;
		return result;
	}
}


static gboolean __lambda5__gtk_widget_button_press_event (GtkWidget* _sender, GdkEventButton* event, gpointer self) {
	gboolean result;
	result = _lambda5_ (_sender, event, self);
	return result;
}


static void applet_setup_popup_menu (GlobalMenuPanelApplet* self, GtkWidget* widget) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (widget != NULL);
	g_signal_connect_object (widget, "button-press-event", (GCallback) __lambda5__gtk_widget_button_press_event, self, 0);
}


gboolean applet_get_disable_module_check (GlobalMenuPanelApplet* self) {
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_disable_module_check;
	return result;
}


void applet_set_disable_module_check (GlobalMenuPanelApplet* self, gboolean value) {
	g_return_if_fail (self != NULL);
	self->priv->_disable_module_check = value;
	g_object_notify ((GObject *) self, "disable-module-check");
}


gboolean applet_get_tiny_mode (GlobalMenuPanelApplet* self) {
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_tiny_mode;
	return result;
}


void applet_set_tiny_mode (GlobalMenuPanelApplet* self, gboolean value) {
	g_return_if_fail (self != NULL);
	self->priv->_tiny_mode = value;
	gtk_widget_set_visible ((GtkWidget*) self->priv->tiny_menubar, value);
	gtk_widget_set_visible ((GtkWidget*) self->priv->main_menubar, !value);
	g_object_notify ((GObject *) self, "tiny-mode");
}


gboolean applet_get_has_handle (GlobalMenuPanelApplet* self) {
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_has_handle;
	return result;
}


void applet_set_has_handle (GlobalMenuPanelApplet* self, gboolean value) {
	g_return_if_fail (self != NULL);
	if (value) {
		panel_applet_set_flags ((PanelApplet*) self, ((0 | PANEL_APPLET_HAS_HANDLE) | PANEL_APPLET_EXPAND_MINOR) | PANEL_APPLET_EXPAND_MAJOR);
	} else {
		panel_applet_set_flags ((PanelApplet*) self, (0 | PANEL_APPLET_EXPAND_MINOR) | PANEL_APPLET_EXPAND_MAJOR);
		panel_applet_set_size_hints ((PanelApplet*) self, NULL, 0, 0);
	}
	self->priv->_has_handle = value;
	g_object_notify ((GObject *) self, "has-handle");
}


static void _applet_on_active_window_changed_gnomenu_global_menu_bar_active_window_changed (GnomenuGlobalMenuBar* _sender, GnomenuWindow* prev_window, gpointer self) {
	applet_on_active_window_changed (self);
}


static void _applet_on_change_background_panel_applet_change_background (GlobalMenuPanelApplet* _sender, PanelAppletBackgroundType type, GdkColor* color, GdkPixmap* pixmap, gpointer self) {
	applet_on_change_background (self, type, color, pixmap);
}


static void _applet_update_size_panel_applet_change_orient (GlobalMenuPanelApplet* _sender, PanelAppletOrient orient, gpointer self) {
	applet_update_size (self);
}


static void _applet_update_size_panel_applet_change_size (GlobalMenuPanelApplet* _sender, guint size_hint, gpointer self) {
	applet_update_size (self);
}


static void _lambda6_ (GlobalMenuPanelApplet* self) {
	gnomenu_global_settings_attach_to_screen (self->priv->settings, gtk_widget_get_screen ((GtkWidget*) self));
}


static void __lambda6__gtk_widget_screen_changed (GlobalMenuPanelApplet* _sender, GdkScreen* previous_screen, gpointer self) {
	_lambda6_ (self);
}


static GObject * applet_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
	GObject * obj;
	GObjectClass * parent_class;
	GlobalMenuPanelApplet * self;
	parent_class = G_OBJECT_CLASS (applet_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = APPLET (obj);
	{
		GnomenuGlobalSettings* _tmp1_;
		GtkMenuItem* item;
		GdkColor color = {0};
		GdkPixmap* pixmap;
		PanelAppletBackgroundType bgtype = 0;
		GdkPixmap* _tmp4_;
		PanelAppletBackgroundType _tmp3_;
		GdkPixmap* _tmp2_ = NULL;
		self->priv->settings = (_tmp1_ = gnomenu_global_settings_get (gdk_screen_get_default ()), _g_object_unref0 (self->priv->settings), _tmp1_);
		gtk_widget_add_events ((GtkWidget*) self, (gint) GDK_KEY_PRESS_MASK);
		gtk_widget_set_visible ((GtkWidget*) self->priv->menubars, TRUE);
		gtk_container_add ((GtkContainer*) self, (GtkWidget*) self->priv->menubars);
		gtk_widget_set_visible ((GtkWidget*) self->priv->switcher, TRUE);
		gtk_container_add ((GtkContainer*) self->priv->menubars, (GtkWidget*) self->priv->switcher);
		applet_setup_popup_menu (self, (GtkWidget*) self->priv->switcher);
		applet_setup_popup_menu (self, (GtkWidget*) self->priv->main_menubar);
		gtk_container_add ((GtkContainer*) self->priv->menubars, (GtkWidget*) self->priv->main_menubar);
		gtk_container_add ((GtkContainer*) self->priv->menubars, (GtkWidget*) self->priv->tiny_menubar);
		gtk_widget_set_visible ((GtkWidget*) self->priv->main_menubar, TRUE);
		gtk_widget_set_visible ((GtkWidget*) self->priv->tiny_menubar, FALSE);
		item = (GtkMenuItem*) g_object_ref_sink (gnomenu_global_menu_item_new ());
		gtk_widget_set_visible ((GtkWidget*) item, TRUE);
		gtk_menu_shell_append ((GtkMenuShell*) self->priv->tiny_menubar, (GtkWidget*) item);
		if (gnomenu_global_menu_bar_get_active_window (self->priv->main_menubar) != NULL) {
			switcher_set_current_window (self->priv->switcher, wnck_window_get ((gulong) gnomenu_window_get_xid (gnomenu_global_menu_bar_get_active_window (self->priv->main_menubar))));
		}
		g_signal_connect_object (self->priv->main_menubar, "active-window-changed", (GCallback) _applet_on_active_window_changed_gnomenu_global_menu_bar_active_window_changed, self, 0);
		gtk_container_child_set ((GtkContainer*) self->priv->menubars, (GtkWidget*) self->priv->main_menubar, "shrink", TRUE, NULL, NULL);
		g_signal_connect_object ((PanelApplet*) self, "change-background", (GCallback) _applet_on_change_background_panel_applet_change_background, self, 0);
		g_signal_connect_object ((PanelApplet*) self, "change-orient", (GCallback) _applet_update_size_panel_applet_change_orient, self, 0);
		g_signal_connect_object ((PanelApplet*) self, "change-size", (GCallback) _applet_update_size_panel_applet_change_size, self, 0);
		applet_set_has_handle (self, FALSE);
		panel_applet_set_background_widget ((PanelApplet*) self, (GtkWidget*) self);
		pixmap = NULL;
		bgtype = (_tmp3_ = panel_applet_get_background ((PanelApplet*) self, &color, &_tmp2_), pixmap = (_tmp4_ = _tmp2_, _g_object_unref0 (pixmap), _tmp4_), _tmp3_);
		applet_on_change_background (self, bgtype, &color, pixmap);
		g_signal_connect_object ((GtkWidget*) self, "screen-changed", (GCallback) __lambda6__gtk_widget_screen_changed, self, 0);
		_g_object_unref0 (pixmap);
		_g_object_unref0 (item);
	}
	return obj;
}


static void applet_class_init (GlobalMenuPanelAppletClass * klass) {
	char** _tmp0_ = NULL;
	applet_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (GlobalMenuPanelAppletPrivate));
	G_OBJECT_CLASS (klass)->dispose = applet_real_dispose;
	GTK_WIDGET_CLASS (klass)->button_press_event = applet_real_button_press_event;
	GTK_WIDGET_CLASS (klass)->size_request = applet_real_size_request;
	G_OBJECT_CLASS (klass)->get_property = applet_get_property;
	G_OBJECT_CLASS (klass)->set_property = applet_set_property;
	G_OBJECT_CLASS (klass)->constructor = applet_constructor;
	G_OBJECT_CLASS (klass)->finalize = applet_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), APPLET_DISABLE_MODULE_CHECK, g_param_spec_boolean ("disable-module-check", "disable-module-check", "disable-module-check", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), APPLET_TINY_MODE, g_param_spec_boolean ("tiny-mode", "tiny-mode", "tiny-mode", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), APPLET_HAS_HANDLE, g_param_spec_boolean ("has-handle", "has-handle", "has-handle", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	applet_subs = (_tmp0_ = g_new0 (char*, 6 + 1), _tmp0_[0] = g_strdup ("@Preferences@"), _tmp0_[1] = g_strdup (_ ("_Preferences")), _tmp0_[2] = g_strdup ("@Help@"), _tmp0_[3] = g_strdup (_ ("_Help")), _tmp0_[4] = g_strdup ("@About@"), _tmp0_[5] = g_strdup (_ ("_About")), _tmp0_);
	applet_subs_length1 = 6;
}


static void applet_instance_init (GlobalMenuPanelApplet * self) {
	self->priv = APPLET_GET_PRIVATE (self);
	self->priv->menubars = g_object_ref_sink (gnomenu_menu_bar_box_new ());
	self->priv->main_menubar = g_object_ref_sink (gnomenu_global_menu_bar_new ());
	self->priv->tiny_menubar = g_object_ref_sink (gnomenu_menu_bar_new ());
	self->priv->switcher = g_object_ref_sink (switcher_new ());
	self->priv->initialized = FALSE;
	self->priv->disposed = FALSE;
	self->priv->_disable_module_check = FALSE;
	self->priv->_tiny_mode = FALSE;
	self->priv->_has_handle = FALSE;
}


static void applet_finalize (GObject* obj) {
	GlobalMenuPanelApplet * self;
	self = APPLET (obj);
	_g_object_unref0 (self->priv->settings);
	_g_object_unref0 (self->priv->menubars);
	_g_object_unref0 (self->priv->main_menubar);
	_g_object_unref0 (self->priv->tiny_menubar);
	_g_object_unref0 (self->priv->switcher);
	G_OBJECT_CLASS (applet_parent_class)->finalize (obj);
}


GType applet_get_type (void) {
	static volatile gsize applet_type_id__volatile = 0;
	if (g_once_init_enter (&applet_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (GlobalMenuPanelAppletClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) applet_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (GlobalMenuPanelApplet), 0, (GInstanceInitFunc) applet_instance_init, NULL };
		GType applet_type_id;
		applet_type_id = g_type_register_static (PANEL_TYPE_APPLET, "GlobalMenuPanelApplet", &g_define_type_info, 0);
		g_once_init_leave (&applet_type_id__volatile, applet_type_id);
	}
	return applet_type_id__volatile;
}


static void applet_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	GlobalMenuPanelApplet * self;
	self = APPLET (object);
	switch (property_id) {
		case APPLET_DISABLE_MODULE_CHECK:
		g_value_set_boolean (value, applet_get_disable_module_check (self));
		break;
		case APPLET_TINY_MODE:
		g_value_set_boolean (value, applet_get_tiny_mode (self));
		break;
		case APPLET_HAS_HANDLE:
		g_value_set_boolean (value, applet_get_has_handle (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void applet_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	GlobalMenuPanelApplet * self;
	self = APPLET (object);
	switch (property_id) {
		case APPLET_DISABLE_MODULE_CHECK:
		applet_set_disable_module_check (self, g_value_get_boolean (value));
		break;
		case APPLET_TINY_MODE:
		applet_set_tiny_mode (self, g_value_get_boolean (value));
		break;
		case APPLET_HAS_HANDLE:
		applet_set_has_handle (self, g_value_get_boolean (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}




